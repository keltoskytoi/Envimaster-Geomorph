---
title: "CENITH hollow validation"
author: "Andreas Schönberg"
date: "26 September 2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### Description

The function CENITH hollow validation is a derivate of the CENITH validation wrapper. It is used to test input values for the moving window and to validate the results using a supervised created point layer (validation points) with position of hollow shades.

Development information:
The function uses CENITH hollow functionality (a wrapper for the 'ForestTools' package (Plowright 2018) ) but returns a dataframe with the results of testet parameters.

citation ForestTools:

  Andrew Plowright (2018). ForestTools: Analyzing Remotely Sensed Forest Data. R package version
  0.2.0. https://CRAN.R-project.org/package=ForestTools

### Parameters 
Both a and b for moving window and the height (depth of hollow but positiv value requred for ForestTools) can be tested. If the input values will result in an error later the function doesnt start and show error.

### Results

The returning results show the tested a,b,height values and rates about the quality of the segmenatation in realtion to the validation points. "Hitrate" is the amount of validation points which have an polygon, over are empty poylgons, under are validation points without a poylgon. Further the returning poylgons are related to the amount of validation points in a factor (1.00 = same amount, eg 10 polygons and 5 validation ponits reslut in a factor of 0.5)

If the hitrate is 100% not all validation points must have an polygon. A high precision segmentation has a high hitrate AND a relation polygons to validation point near "1.00"

### Filters
optional different filter sizes can be used to perform the segmentation on a filtered SOM.
Filter size will be FxF sum filters.

Requires "ForestTools","uavRst","sf","sp" and "rgeos" packages.

```{r cars}
#' Mandatory: Cenith Hollow Validation v1
#'
#' @description Optional: used to test optimal moving window for the Cenith Segmentation
#' @name Mandatory Cenith  
#' @export Mandatory Cenith

#' @param Mandatory if function: chm - a canopy height model or raster with elevation values
#' @param Mandatory if function: a, b - parameters for moving window
#' predefinition in var is recommended
#' @param Mandatory if function: h - minimum height to detect trees
#' @param Mandatory if function: optional f - numeric, must be odd, fxf filter,
#' uses a spatial sum filter
#' @param Mandatory if function: vp - a pointlayer (shp) with positions of Objects
#' @param Mandatory if function: min - the minimum area in m² for polygons
#' @param Mandatory if function: max - the maximum area in m² for polygons

#note: v1 merging polygons and clipping of min and max area

cenith_hollow_val <-function(chm,f=1,a,b,h,vp,min,max){
  result <- data.frame(matrix(nrow = 3, ncol = 5))
  maxsom <- raster::cellStats(chm, "max")
  if (max(h)>maxsom){
    stop("max of h is higher than the highest cell in som")
  }
  if (f>1){
    cat(paste0("### Cenith computes som with sum filter ",as.factor(f)," ###",sep = "\n"))
    chm <- raster::focal(chm,w=matrix(1/(f*f),nrow=f,ncol=f))
  } else {chm = chm}   ### filter function seperate
  
  
for (c in seq(1:length(h))){
  cat(paste0("### Cenith starts with loop h ",as.factor(c)," / ",as.factor(length(h))," ###",sep = "\n"))
  cat       ("#############################",sep="\n")
  if(c==1){
    res  <-cenith_hollow_val_a_v1(chm,a,b,h[c],vp,min,max)
  }    else {
    res2 <-cenith_hollow_val_a_v1(chm,a,b,h[c],vp,min,max)
    res= rbind(res,res2)}


  
}   
  names(res)<- c("a","b","height","hit","sum_area","miss","obj/vp","empty","nobj_final","poly_after_merge","poly_seg")
  
  cat       ("################################",sep="\n")
  cat       ("   CC EEEE N   N  I TTTTT H   H ",sep="\n")
  cat       ("  C   E    NN  N  I   T   H   H ",sep="\n")
  cat       (" C    EE   N N N  I   T   HHHHH ",sep="\n")
  cat       ("  C   E    N  NN  I   T   H   H ",sep="\n")
  cat       ("   CC EEEE N   N  I   T   H   H ",sep="\n")
  cat       ("                                ",sep="\n")
  cat       ("Finished hollow validation ",sep="\n")
  return(res)
}
```

### Subfunction for deeper level loop

```{r }
#' Mandatory: Cenith Hollow Validation v1 Subfunction validation for value a
#'
#' @description Optional: subfunction for running val4b over a
#' @name Mandatory Cenith  
#' @export Mandatory Cenith

#' @param Mandatory if function: chm - a canopy height model
#' @param Mandatory if function: a, b - parameters for moving window
#' @param Mandatory if function: h - minimum height to detect trees
#' @param Mandatory if function: optional vp - a pointlayer (shp) with positions of Trees

#Note v1: uses cleaned sf

cenith_hollow_val_a_v1 <-function(chm,a,b,h,vp,min,max){
  result <- data.frame(matrix(nrow = 3, ncol = 5))
  
for (i in seq(1:length(a))){
  cat(paste0("### Cenith starts with loop a ",as.factor(i)," / ",as.factor(length(a))," ###",sep = "\n"))
  cat       ("#############################",sep="\n")

 
   if(i==1){
    res  <-cenith_hollow_val_b_v1(chm,a[i],b,h,vp,min,max)
  }    else {
    res2 <-cenith_hollow_val_b_v1(chm,a[i],b,h,vp,min,max)
    res= rbind(res,res2)}


  
  
}

  return(res)
}


```

### Subfunction for deepest loop, contains main workflow

```{r }
#' Mandatory: Cenith Hollow Validation v1 Subfunction validation for value b
#'
#' @description Optional: primary subfunction for segmentation over b and calculate statistc results
#' @name Mandatory Cenith  
#' @export Mandatory Cenith

#' @param Mandatory if function: chm - a canopy height model
#' @param Mandatory if function: a, b - parameters for moving window
#' @param Mandatory if function: h - minimum height to detect trees
#' @param Mandatory if function: optional vp - a pointlayer (shp) with positions of Trees
#' @param Mandatory if function: min - minimum area for a polygon
#' @param Mandatory if function: max - maximum area for a polygon

#Note v1: uses cleaned sf and added merging intersection polygons, clipping min and max polygons



cenith_hollow_val_b_v1 <- function(chm,a,b,h,vp,min,max){
  result <- data.frame(matrix(nrow = length(b), ncol = 8)) # ncol = n information stored
  for (j in seq(1:length(b))){
    cat       (" ",sep="\n")
    
    cat(paste0("### Cenith starts loop b ",as.factor(j)," / ",as.factor(length(b))," ###",sep = "\n"))



    tpos = sf_ft_vwf_clean(chm, 
                            winFun = function(x){x * a + b[j]}, 
                            minHeight = h, 
                            verbose = TRUE)
    
    #cat(paste0("### Cenith computes polygon layer with b",as.factor(j)," / ",as.factor(length(b))," ###",sep = "\n"))
    seg <- sf_chmseg_clean(chm = chm,
                     treepos = tpos,
                     format = "polygons",
                     minTreeAlt = h,
                     verbose = TRUE)
    #########################
    #load function for merging
    clusterSF <- function(sfpolys){
      dmat = st_distance(sfpolys)
      hc = hclust(as.dist(dmat), method="single")
      groups = cutree(hc, h=0.5)
      d = st_sf(
        geom = do.call(c,
                       lapply(1:max(groups), function(g){
                         st_union(sfpolys[groups==g,])
                       })
        )
      )
      d$group = 1:nrow(d)
      d
    }
    #################################
    # convert sp to sf
    poly_sf <- st_as_sf(seg)
    #run merging
    merc_seg_sf <- clusterSF(poly_sf)
    #convert sf to sp
    merc_sp <- sf:::as_Spatial(merc_seg_sf)
    
    ########################
    for (s in 1:length(merc_sp)){
    merc_sp[s,2] <- gArea(merc_sp[s,])
    }
    
    names(merc_sp) <- c("group","area")
    
    merc_sp
    merc_min <- merc_sp[merc_sp$area>min,]
    merc_min
    
    merc_seg <- merc_min[merc_min$area<max,]
    merc_seg
    
    
    
    
    ########################
    #cat(paste0("### Cenith calculates precision ratios for b ",as.factor(j)," / ",as.factor(length(b))," ###",sep = "\n"))
    stat <- ForestTools::sp_summarise(vp, merc_seg) # compute data points in polygons
    stat[is.na(stat$TreeCount)] <- 0 # na to 0
    
    pkb <- sum(stat$TreeCount<1) # amount polygon without tree (miss)
    pb <- sum(stat$TreeCount==1) # amount polygon with exact 1 tree (hit)
    pmb <-sum(stat$TreeCount>1) # amount polygon with more than 1 tree (miss)
    
    hit = pb/length(stat$TreeCount) # calc hit ration in percent (amount of exact trees
    over = pkb/length(stat$TreeCount) #calc empty ration in percent (amount of polygon without trees)
    under = pmb/length(stat$TreeCount) # mis.rati (or jan error) miss rate in percent (amount of polygons with more than 1 Tree)
    nobj_vp = length(merc_seg)/length(vp)
    area =  sum(merc_seg$area)
    nobj = length(merc_seg)    # n polygons after clipping min and max
    org_obj = length(merc_sp)  # n polygons after merging
    org_seg = length(seg)      # seg the polygons computed by segmentation
    
    
    result[j, 1] <- a
    result[j, 2] <- b[j]
    result[j, 3] <- h
    result[j, 4] <- hit
    result[j, 7] <- nobj_vp
    result[j, 6] <- over
    result[j, 5] <- area
    result[j, 8] <- under
    result[j, 9] <- paste(nobj,"/",length(vp))
    result[j,10] <- org_obj
    result[j,11] <- org_seg
  } 
  return(result)
}

```

